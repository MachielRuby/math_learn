bool is_prime(int x)
{
    if (x < 2) return false;
    for (int i = 2; i <= x / i; i ++ )              // 注意循环条件
        if (x % i == 0)
            return false;
    return true;
}
https://www.acwing.com/blog/content/4021/

分解质因子
#include <iostream>
using namespace std;

void divide(int x)
{
	for (int i = 2; i <= x / i; i++) {
		if (x % i == 0) {
			int cnt = 0;
			while (x % i == 0) {
				x /= i;
				cnt++;
			}
			cout << i << ' ' << cnt << endl;
		}
	}
	if (x > 1) cout << x << ' ' << 1 << endl;
}

int main()
{
	int n = 16;
	divide(n);
	return 0;
}

66  2 3 11


艾式算法
const int N = 100000; // 假设筛选范围为 100000

int primes[N], cnt; // primes[]存储所有素数
bool st[N];         // st[x]存储x是否被筛掉

void get_primes(int n) {
    for (int i = 2; i <= n; i++) {
        if (st[i]) continue; // 如果i已经被筛掉了，则跳过
        primes[cnt++] = i;   // 把i存入素数数组中
        for (int j = i + i; j <= n; j += i) {
            st[j] = true; // 筛掉i的倍数，从i的平方开始
        }
    }
}

线性筛法
int primes[N], cnt;     // primes[]存储所有素数
bool st[N];             // st[x]存储x是否被筛掉

void get_primes(int n)
{
    for (int i = 2; i <= n; i ++ )
    {
        if (!st[i]) primes[cnt ++ ] = i;
        for (int j = 0; primes[j] <= n / i; j ++ )
        {
            st[primes[j] * i] = true;               // 用最小质因子去筛合数primes[j] * i
            if (i % primes[j] == 0) break;          // 若prime[j]是i的最小质因子，则prime[j+1] * i的最小质因子依旧是prime[j]
        }
    }
}

求所有约数：
vector<int> get_divisors(int x)
{
    vector<int> res;
    for (int i = 1; i <= x / i; i ++ )
        if (x % i == 0)
        {
            res.push_back(i);
            if (i != x / i) res.push_back(x / i);
        }
    sort(res.begin(), res.end());
    return res;
}

约数个数定理：
LL countDivisorsAndPrimeFactors(int x) {
	unordered_map<int, int> primes;

	// 质数分解
	for (int i = 2; i <= x / i; i++) {
		while (x % i == 0) {
			x /= i;
			primes[i]++;
		}
	}
	if (x > 1) primes[x]++;

	// 约数个数定理
	LL res = 1;
	for (auto elem : primes) {
		res *= (elem.second + 1);
	}

	return res;
}

约数之和定理：
p + p1 +p2 = ((1xp+1)xp+1)...
// 计算一个数的约数之和
LL sumOfDivisors(int x) {
    unordered_map<int, int> primes;

    // 质因数分解
    for (int i = 2; i <= x / i; i++) {
        while (x % i == 0) {
            x /= i;
            primes[i]++;
        }
    }
    if (x > 1) primes[x]++;

    // 使用公式计算约数之和
    LL sum = 1;
    for (auto& [p, a] : primes) {
        LL term = 1, factor = 1;
        while (a--) {
            factor *= p;
            term += factor;
        }
        sum *= term;
    }
    return sum;
}

最大公约数：
int gcd(int a,int b)
{
     return b?gcd(b,a%b):a;
}
gcd(a,b) = gcd(b,a mod b)
gcd(a,0) = a

欧拉函数
互相为质数的个数

#include <iostream>
using namespace std;

int phi(int x)
{
	int res = x;
	for (int i = 2; i <= x / i; i++)
		if (x % i == 0)
		{
			res = res / i * (i - 1);
			while (x % i == 0) x /= i;
		}
	if (x > 1) res = res / x * (x - 1);

	return res;
}

int main()
{
	int n = 10;
	int euler_phi = phi(n);
	cout << "欧拉函数φ(" << n << ") = " << euler_phi << endl;

	return 0;
}

//φ(n) = n(1-1/p1)(1-1/p2)....(1-1/pk); (p1-1)/p1