###　输入输出

```c++
int %d
double %lf
char %c
char[] %s 遇到空格和换行就结束
cin 遇到空格和换行结束
取消同步流加速cin和cout
int main()
{
    ios::sync_with_stdio(0),cin.tie(0),cout.tie(0);
}
scanf 和 printf格式化输入输出效率高
一般不混用
```

### string

```cpp
std::string str1;初始化
std::string str2 = str1.substr(0,5);
转为char s.c_str();
1、获取长度 .length()
2、拼接 + append
3、find  
    std::string str = "hello world";
	size_t pos =str.find("hello");
if(pos!=std::string::npos)
{
}
else
{
}
4、replace
str.replace(7,5,"universe");
5、提取子字符串
    str1 = str.substr(num,num);
6、字符串比较
    int result = str1.compare(str2); 
{
    =0
    >0
    <0
}
7、auto迭代
```

### 库函数的使用

```cpp
islower/isupper cctype 头文件
小写转大写 -32
大写转小写+32
二分：
int main()
{
	vector<int>nums = { 1,3,4,5,7,8 };
	bool found = std::binary_search(nums.begin(), nums.end(), 5);
	cout << found << endl;
	return 0;
}
第一个>=8：
cout << (lower_bound(nums.begin(), nums.end(), 8) - nums.begin()) << endl;

```

```cpp
排序：
sort 在algorithm采用快速排序
sort(起始地址，结束地址)
sort(起始迭代器，end(),*比较函数)
例子：
vector<int> v = {5,1,3,9,11};
sort(v.begin(),v.end(),cmp);
bool cmp(const int &u,const int&v);
lambda:sort(v.begin(),v.end(),[](const int&u,const int&v){
    return u>v;
});
结构体排序：
    struct Node
    {
        int u,v;
        bool operator<(const Node&m)const
        {
            return u==m.u?v<m.v:u<m.u;
		}
	}
```

```
memset(ptr,value,num);重置大小cstring
memset(arr,0,sizeof(arr));
每个bite都化为00000001 00000001 00000001 00000001
swap();交换函数
reverse();反转algorithm
unique(first,last);去掉容器中相邻重复元素的函数 algorithm中
不是删掉是挪动到后面
```

![image-20240401091629850](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401091629850.png)

```cpp
全排列：
while (next_permutation(nums.begin(), nums.end()))
{
	for (int num : nums)
	{
		cout << num << " ";
	}
	cout << endl;
}除了本身；
```

![image-20240401091904918](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401091904918.png)


![image-20240401092313430](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401092313430.png)
最值查找

```
min,max 
min_element max_element 返回地址或者迭代器
*max_elemenet(v.begin(),v.end()) algorithm

```

![image-20240401092834881](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401092834881.png)
### stl

list:
![image-20240401094556881](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401094556881.png)

常用函数

![image-20240401094659846](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401094659846.png)


![image-20240401094849719](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401094849719.png)


### map

```cpp
map
multimap
unordered_map 不稳定
```

![image-20240401095025752](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401095025752.png)


![image-20240401095040323](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401095040323.png)

![image-20240401095221114](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401095221114.png)


![image-20240401095308212](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401095308212.png)
![image-20240401095332939](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401095332939.png)
![image-20240401122642772](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401122642772.png)

### pair

![image-20240401122740415](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401122740415.png)

嵌套pair

![image-20240401122936149](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401122936149.png)

### queue

![image-20240401123251171](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401123251171.png)

### priority_queue

![image-20240401123330181](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401123330181.png)

自定义：

![image-20240401123604659](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401123604659.png)


### deque

![image-20240401123628303](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401123628303.png)







### 差分模板

```cpp
const int n = 1e5 + 5;
int a[n],d[n];
void solve(int n,int m)
{
	for(int i = 1;i<=n;i++)
	{
        cin>>a[i];
	}
    for(int i = 1;i<=n;i++)
    {
        d[i] = a[i]-a[i-1];
	}
    while(m--)
    {
        int x,y,z;
        cin>>x>>y>>z;
        d[x] += z;
        d[y+1] -=z;
	}
    for(int i = 1;i<=n;i++)
    {
        a[i] = a[i-1]+d[i];
	}
}
```



### 二分：

![image-20240401193231866](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401193231866.png)

```cpp
int l = 0,r = 1e9;
while(l+1!=r)
{
	int mid = (l+r)/2;
	if(a[mid]>=x)r= mid;
	else l = mid;
}
cout<<r<<"\n";
```

![image-20240401194024800](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401194024800.png)


跳石头

```cpp
#include <iostream>
using namespace std;
#include<bits/stdc++.h>
const int N = 5e4 + 9;
using ll = long long;
int a[N],L,m,n;
int check(int mid)
{
  int res = 0,lst = 0;
  for(int i =1,lst = 0;i<=n;i++)
  {
    if(a[i]-a[lst]<mid)
    {
      res++;
      continue;
    }
    lst = i;
  }
  if(L-a[lst]<mid) return m+1;
  return res;
}
int main()
{
  // 请在此输入您的代码
  ios::sync_with_stdio(0),cin.tie(0);
  cin>>L>>n>>m;
  for(int i = 1;i<=n;i++)
  {
    cin>>a[i];
  }
  long long l = 0,r = 1e9+5;
  while(l+1!=r)
  {
    long long mid = (l+r)/2;
    if(check(mid)<=m) l = mid;
    else r = mid;
  }
  cout<<l<<"\n";
  return 0;
}
```

```cpp
肖恩的苹果林
#include <iostream>
using namespace std;
#include<algorithm>
const int n1 = 1e5+5;
int n,m;
long long a[n1];
int check(int mid)
{
  int res = 0,lst;
  for(int i = 1,lst = 0;i<=n;i++)
  {
    if(lst&&a[i]-a[lst]<mid)continue;
    res++,lst = i;
  }
  return res;
}
int main()
{
  // 请在此输入您的代码

  cin>>n>>m;
  for(int i = 1;i<=n;i++)
  {
    cin>>a[i];
  }
  sort(a+1,a+1+n);
  long long l = 0,r = 1e9+5;
  while(l+1!=r)
  {
    long long mid = (l+r)/2;
    if(check(mid)>=m)
    {
      l = mid;
    }
    else
    {
      r = mid;
    }
  }
  cout<<l<<"\n";
  return 0;
}
```

![image-20240401202420720](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401202420720.png)



肖恩的乘法表：

```cpp
#include <iostream>
using namespace std;
using ll  = long long;
ll n,m,k;
ll rank1(ll mid)
{
  ll res = 0;
  for(int i =1;i<=n;i++)
  {
    res += min(m,mid/i);
  }
  return res;

}

int main()
{
  // 请在此输入您的代码
  cin>>n>>m>>k;
  ll l =0,r = 1e14;
  while(l + 1!=r)
  {
    ll mid = (l+r)>>1;
    if(rank1(mid)>=k)r = mid;
    else l = mid;
  }
  cout<<r<<"\n";
  return 0;
}


```

### 构造

![image-20240401224251963](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401224251963.png)


![image-20240401224509022](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401224509022.png)

### 转进制

![image-20240401225718596](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240401225718596.png)

模板使用

```cpp
#include <iostream>
using namespace std;
using ll = long long;
const int N = 50;
int a[N];
int main()
{
  // 请在此输入您的代码
  string s = "2021ABCD";
  for(int i = 0;i<s.length();i++)
  {
    if('0'<=s[i]&&s[i]<='9')a[i+1] = s[i] - '0';
    else a[i+1] = s[i] -'A'+10;
  }
  ll x = 0;
  for(int i = 1;i<= s.length();i++)
  {
    x = x * 16 + a[i];
  }
  cout<<x<<"\n";

  return 0;
}

乱转版本
#include <iostream>
using namespace std;
#include<algorithm>
using ll = long long;
const int N = 1000;
int a[N];
char ch [] = {'0','1','2','3','4','5','6','7','8','9','A','B','C','D','E','F'};
void del(int n,int m,string s)
{
  for(int i = 0;i<s.length();i++)
  {
    if(s[i]>='0'&&s[i]<='9')
    {
      a[i+1] = s[i] -'0';
    } 
    else
    {
      a[i+1] = s[i] - 'A'+10;
    }
  }
  ll x = 0;
  for(int i = 1;i<=s.length();i++)
  {
    x = x*n +a[i];
  }
  string ans;
  while(x)
  {
    ans += ch[x%m];
    x /= m;
  }
  reverse(ans.begin(),ans.end());
  cout<<ans<<"\n";
}
int main()
{
  // 请在此输入您的代码
  int t;
  cin>>t;
  while(t--)
  {
    int n,m;
    cin>>n>>m;
    string s;
    cin>>s;
    del(n,m,s);
  }
  return 0;
}
```

###　离散化

![image-20240402001416796](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240402001416796.png)


```cpp
#include<bits/stdc++.h>
using namespace std;
vector<int> v;
int getidx(int x)
{
	return lower_bound(L.begin(), L.end(), x) - L.begin();
}
const int N = 1e5 + 9;
int a[N];
int main()
{
	int n; cin >> n;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[i];
	}
	for (int i = 1; i <= n; i++)
	{
		L.push_back(a[i]);
	}
    sort(L.begin(),L.end());
	L.erase(unique(L.begin(), L.end()), L.end());
	return 0;
	return 0;

}
```



###　枚举

![image-20240402003155516](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240402003155516.png)


### 模拟算法



![image-20240402112112292](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240402112112292.png)



#### 扫雷

```cpp
#include <iostream>
using namespace std;
const int N = 1e2+5;
int a[N][N] ={0},b[N][N]={0};
int main()
{
  // 请在此输入您的代码
  int n,m;
  cin>>n>>m;
  for(int i = 1;i<=n;i++)
  {
    for(int j = 1;j<=m;j++)
    {
      cin>>a[i][j];
    }
  }
  
  for(int i = 1;i<=n;i++)
  {
    for(int j = 1;j<= m;j++)
    {
      if(a[i][j]==1)
      {
        b[i][j] = 9;
        continue;
      }
      //扫描
      for(int _i = max(1,i-1);_i<=min(n,i+1);_i++)
      {
        for(int _j = max(1,j-1);_j<=min(m,j+1);++_j)
        {
          if(a[_i][_j])b[i][j] ++;
        }
      }
    }
  }


  for(int i = 1;i<=n;i++)
  {
    for(int j = 1;j<=m;j++)
    {
      cout<<b[i][j]<<" ";
    }
    cout<<endl;
  }
  return 0;
}
```

### 前缀和

![image-20240402151024321](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240402151024321.png)

```cpp
#include <iostream>
using namespace std;
const int N = 1e5 + 5;
using ll = long long;
long long a[6][N], b[6][N];
const ll p = 1e9 + 7;

int main()
{
	// 请在此输入您的代码
	int n, m;
	cin >> n >> m;
	for (int i = 1; i <= n; i++)
	{
		cin >> a[1][i];
	}
	for (int i = 2; i <= 5; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			a[i][j] = (a[i - 1][j] * a[1][j]) % p;
		}
	}
	for (int i = 1; i <= 5; i++)
	{
		for (int j = 1; j <= n; j++)
		{
			b[i][j] = (b[i][j - 1] + a[i][j]) % p;
		}
	}
	while (m--)
	{
		int l, r, k;
		cin >> l >> r >> k;
		cout << (b[k][r ] - b[k][l-1] + p) % p << "\n";
	}


	return 0;
}
```

小朕的蓝桥平衡穿

```cpp
#include <iostream>
using namespace std;
const int N = 1e5+5;
int a[N] = {0};
int main()
{
  // 请在此输入您的代码
  string s;
  cin>>s;
  int n = s.length();
  for(int i =1;i<=s.length();i++)
  {
    a[i] = a[i-1] +((s[i-1]=='L')?1:-1);
  }
  int ans = 0;
  for(int i =1;i<=n;i++)
  {
    for(int j = i;j<=n;j++)
    {
      if(a[j]-a[i-1]==0)ans= max(ans,j-i+1);
    }
  }

  cout<<ans<<"\n";
  return 0;
}
```



## 时间复杂度

![image-20240402162505404](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240402162505404.png)
###　双指针

![image-20240402162807699](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240402162807699.png)

###　快慢指针

```cpp
#include<iostream>
using namespace std;
const int N = 1e5+6;
int a[N];
int main()
{
  iso::sync_with_stdio(0),cin.tie(0),cout.tie(0);
  int n,m,k;cin>>n>>m>>k;
  for(int i = 1;i<=n;i++)
  {
    cin>>a[i];
  }
  for(int i =1,j=0,cnt = 0;i<=n;i++)
  {
    while(i>j||(j+1<=n&&cnt<k))cnt += (a[++j]>=m);
    if(cnt>=k) ans += r-j+1;
    cnt -= (a[i]>=m);
  }
  cout<<ans<<"\n";
  return 0;
}
```

###　贪心算法

![image-20240402171032267](C:\Users\window\AppData\Roaming\Typora\typora-user-images\image-20240402171032267.png)


### 排序

1、快排

```cpp
#include <iostream>
using namespace std;
const int N = 1e5+5;
int a[N];


int partition(int a[],int l,int r)
{
  int n = l, m = r+1;
  int val = a[l];
  while(1)
  {
    while(n<r&&a[++n]<val);
    while(a[--m]>val);
    if(n>=m)break;
    swap(a[n],a[m]);
  }
  swap(a[m],a[l]);
  return m;
}
void quicksort(int a[],int l, int r)
{
  if(l<r)
  {
    int p = partition(a,l,r);
    quicksort(a,l,p-1);
    quicksort(a,p+1,r);
  }
  
}
int main()
{
  int n;
  cin>>n;
  for(int i = 1;i<=n;i++)
  {
    cin>>a[i];
  }
  quicksort(a,1,n);
  for(int i =1;i<=n;i++)
  {
    cout<<a[i]<<" ";
  }

  // 请在此输入您的代码
  return 0;
}
```





###　回溯算法模板

```cpp
int a[N];
bool vis[N];

void dfs(int dep)
{
	if(dep==n+1)
	{
		for(int i =1;i<=n;i++)cout<<a[i]<<" ";
        cout<<"\n";
        return;
	}
    
    for(int i = 1;i<=n;i++)
    {
        //排除不合法的路径
        if(vis[i])continue;
        //修改状态
        vis[i] = true;
        a[dep] = i;
        //下一层
        dfs(dep+1);
        //恢复现场
        vis[i] = false;
	}
}
```

